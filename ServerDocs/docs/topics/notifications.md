## Redis Keyspace Notifications

**重要**：键空间通知(keyspace notification)功能自2.8.0版本开始可用。

---

### Feature overview

键空间通知允许客户端订阅 Pub/Sub channels，以便以某种方式接受影响 Redis 数据集的事件。

可能接收的事件实例如下：
- 所有影响给定 key 的命令。
- 所有接收 LPUSH 操作的 key。
- 所有在数据库 0 中到期的 key。

时间使用 Redis 的普通 Pub/Sub 层传递，因此实现了 Pub/Sub 的客户端无需修改即可使用此功能。

由于 Redis 的 Pub/Sub 是 *fire and forget*，因此如果你的应用要求 **可靠的事件通知**(reliable notification)，目前还不能使用这个功能，也就是说，如果你的 Pub/Sub 客户端断开连接，并在稍后重连，那么所有在客户端断开期间发送的事件将会丢失。

将来有计划允许更可靠的事件传递，但可能会在更一般的层面上解决，要么为 Pub/Sub 本身带来可靠性，要么允许 Lua 脚本拦截 Pub/Sub 的消息以执行推送等操作，就像往队列里推送事件一样。

---

### Type of events

键空间通知的实现是为每一个影响 Redis 数据空间的操作发送两个不同类型的事件。例如，在数据库 0 中名为 `mykey` 的键上执行 [DEL](../commands/DEL.md) 操作，将触发两条消息的传递，完全等同于下面两个 [PUBLISH](../commands/publish.md) 命令：

```
PUBLISH __keyspace@0__:mykey del
PUBLISH __keyevent@0__:del mykey
```

以上很容易看出一个频道(channel)允许监听所有键 `mykey` 的所有事件，以及另一个频道允许获取有关所有 DEL 操作目标键的信息。

第一种事件，在频道中使用 `keyspace` 前缀的被叫做 **键空间通知**(Key-space notification)，第二种，使用 `keyevent` 前缀的，被叫做 **键事件通知**(Key-event notification)。
- 键空间频道接收到的消息是事件的名称。
- 键事件频道接收到的消息是键的名称。

可以只启用其中一种通知，以便只传递我们感兴趣的事件子集。

---

### Configuration

默认情况下，键空间事件通知是不启用的，因为虽然不太明智，但该功能会消耗一些 CPU。可以使用 redis.conf 中的 `notify-keyspace-events` 或者使用 **CONFIG SET**命令来开启通知。

将参数设置为空字符串会禁用通知。为了开启通知功能，使用了一个非空字符串，有多个字符组成，每个字符都有其特殊的含义，具体参见下表：

```
K     键空间事件, 以 __keyspace@<db>__ 前缀发布。
E     键事件事件,以 __keyevent@<db>__ 前缀发布。
g     通用命令（非特定类型），如 DEL, EXPIRE, RENAME 等等。
$     字符串命令。
l     列表命令。
s     集合命令。
h     哈希命令。
z     有序集合命令。
t     流命令。
d     模块键类型事件。
x     过期事件 (每次键到期时生成的事件)。
e     逐出事件 (当一个键由于达到最大内存而被逐出时产生的事件)。
m     键缺失事件 (访问不存在的键时生成的事件)
A     "g$lshztxed" 的别名，因此字符串 "AKE" 表示除了 "m" 的所有的事件，。
```

字符串中应当至少存在 K 或 E，否则将不会传递事件，不管字符串中其余部分是什么。

例如，要为列表开启键空间事件，则配置参数必须设置为 Kl，以此类推。

字符串 KEA 可以用于开启所有可能的事件。

---

### Events generated by different commands

根据以下列表，不同的命令会生成不同类型的事件。

- [DEL](../commands/DEL.md) 命令为每一个删除的 key 生成一个 `del` 事件。
- [RENAME](../commands/RENAME.md) 生成两个事件，一个是为源 key 生成一个 `rename_from` 事件，一个是为目标 key 生成的 `rename_to` 事件。
- [MOVE](../commands/MOVE.md) 生成两个事件，一个是为源 key 生成一个 `move_from` 事件，一个是为目标 key 生成的 `move_to` 事件。
- [COPY](../commands/COPY.md) 生成一个 `copy_to` 事件。
- [MIGRATE](../commands/migrate.md) 如果源 key 被删除，则生成一个 `del` 事件。
- [RESTORE](../commands/RESTORE.md) 为 key 生成一个 `restore` 事件。
- [EXPIRE](../commands/EXPIRE.md) 及其所有变体（ [PEXPIRE](../commands/PEXPIRE.md)、[EXPIREAT](../commands/EXPIREAT.md)、[PEXPIREAT](../commands/PEXPIREAT.md) ）在使用正数超时时间（或未来时间戳）调用时会生成一个 `expire` 事件。请注意，当使用过去的负超时时间或时间戳调用这些命令时，key将被删除，而只会生成一个 `del` 事件。
- [SORT](../commands/SORT.md) 当使用 **STORE** 设置新 key 时，会生成一个 `sortstore` 事件。如果结果列表为空，并且使用了 **STORE** 选项，并且已经存在具有该名称的键，则结果是键被删除，因此在这种情况下，会生成 `del` 事件。
- [SET](../commands/SET.md) 及其所有变体（ [SETEX](../commands/SETEX.md)、[SETNX](../commands/SETNX.md)、[GETSET](../commands/GETSET.md) ）生成 `set` 事件。然而 [SETNX](../commands/SETNX.md) 也会产生一个 `expire` 事件。
- [MSET](../commands/MSET.md) 为每个 key 生成一个 ` set` 事件。
- [SETRANGE](../commands/SETRANGE.md) 生成一个 `setrange` 事件。
- [INCR](../commands/INCR.md)、[DECR](../commands/DECR.md)、[INCRBY](../commands/INCRBY.md)、[DECRBY](../commands/DECRBY.md) 命令都生成 `incrby` 事件。
- [INCRBYFLOAT](../commands/INCRBYFLOAT.md) 生成一个 `incrbyfloat` 事件。
- [APPEND](../commands/APPEND.md) 生成一个 `append` 事件。
- [LPUSH](../commands/LPUSH.md) 和 [LPUSHX](../commands/LPUSHX.md) 生成一个 `lpush` 事件，即使在可变参数情况下也是如此。
- [RPUSH](../commands/RPUSH.md) 和 [RPUSHX](../commands/RPUSHX.md) 生成一个 `rpush` 事件，即使在可变参数情况下也是如此。
- [RPOP](../commands/RPOP.md) 生成一个 `rpop` 事件。此外，如果 key 由于列表中的最后一个元素弹出而被删除，则会生成一个 `del` 事件。
- [LPOP](../commands/LPOP.md) 生成一个 `lpop` 事件。此外，如果 key 由于列表中的最后一个元素弹出而被删除，则会生成一个 `del` 事件。
- [LINSERT](../commands/LINSERT.md) 生成一个 `linsert` 事件。
- [LSET](../commands/LSET.md) 生成一个 `lset` 事件。
- [LREM](../commands/LREM.md) 生成一个 `lrem` 事件，此外，如果结果列表为空或键被移除，将会生成一个 `del` 事件。
- [LTRIM](../commands/LTRIM.md) 生成一个 `ltrim` 事件，此外，如果结果列表为空或键被移除，将会生成一个 `del` 事件。
- [RPOPLPUSH](../commands/RPOPLPUSH.md) 和 [BRPOPLPUSH](../commands/BRPOPLPUSH.md) 生成 `rpop` 事件和 `lpush` 事件。这两种情况下，顺序都将得到保证（`lpush`事件将总是在 `rpop` 事件之后传递）。此外，如果结果列表长度为零且键被删除，则会生成一个 `del` 事件。
- [LMOVE](../commands/LMOVE.md) 和 [BLMOVE](../commands/BLMOVE.md) 生成 `lpop/rpop` 事件（取决于 **wherefrom** 参数）和 `lpush/rpush` 事件（取决于 **whereto** 参数）。在这两种情况下，顺序都是有保证的（`lpush/rpush`事件始终在`lpop/rpop`事件之后传递）。此外，如果结果列表长度为零且键被删除，则会生成一个 `del` 事件。
- [HSET](../commands/HSET.md)、[HSETNX](../commands/HSETNX.md) 和 [HMSET](../commands/HMSET.md) 都生成一个 `hset` 事件。
- [HINCRBY](../commands/HINCRBY.md) 生成一个 `hincrby` 事件。
- [HINCRBYFLOAT](../commands/HINCRBYFLOAT.md) 生成一个 `hincrbyfloat` 事件。
- [HDEL](../commands/HDEL.md) 生成一个 `hdel` 事件，如果结果 hash 为空并且 key 被删除，则额外生成一个 `del` 事件。
- [SADD](../commands/SADD.md) 生成一个 `sadd` 事件，即使在可变参数的情况下，也是如此。
- [SREM](../commands/SREM.md) 生成一个 `srem` 事件，如果结果 set 为空并且键被删除，则额外生成一个 `del` 事件。
- [SMOVE](../commands/SMOVE.md) 为每一个源 key 生成一个 `srem` 事件，为每一个目标 key 生成一个 `sadd` 事件。
- [SPOP](../commands/SPOP.md) 生成一个 `spop` 事件，此外，如果结果 set 为空并且键被删除，则额外生成一个 `del` 事件。
- [SINTERSTORE](../commands/SINTERSTORE.md)、[SUNIONSTORE](../commands/SUNIONSTORE.md)、[SDIFFSTORE](../commands/SDIFFSTORE.md) 分别生成 `sinterstore`、`sunionstore`、`sdiffstore`事件。在特殊情况下，结果集是空的，并且存储结果的key已经存在，因为删除了key，所以会生成 `del` 事件。
- **ZINCR** 生成 `zincr` 事件。
- [ZADD](../commands/ZADD.md) 生成一个 `zadd` 事件，即使添加了多个元素也是如此。
- [ZREM](../commands/ZREM.md) 生成单个 `zrem` 事件，即使删除多个元素也是如此。当结果 sorted set 为空并且生成了新 key，会生成一个额外的 `del` 事件。
- **ZREMBYSCORE** 生成一个 `zrembyscore` 事件。当结果 sorted set 为空并且生成了新 key，会生成一个额外的 `del` 事件。
- **ZREMBYRANK** 生成一个 `zrembyrank` 事件。当结果 sorted set 为空并且生成了新 key，会生成一个额外的 `del` 事件。
- [ZDIFFSTORE](../commands/ZDIFFSTORE.md)、[ZINTERSTORE](../commands/ZINTERSTORE.md) 和 [ZUNIONSTORE](../commands/ZUNIONSTORE.md) 分别生成 `zdiffstore`、`zinterstore` 和 `zunionstore` 事件。 在特殊情况下，结果 sorted set 为空，并且存储结果的 key 已经存在，由于删除了 key，因此生成了 `del` 事件。
- [XADD](../commands/XADD.md) 生成一个 `xadd` 事件，当与 **MAXLEN** 子命令一起使用时，它可能跟在一个 `xtrim` 事件之后。
- [XDEL](../commands/XDEL.md) 生成一个 `xdel` 事件，即使删除了多个条目，也是如此。
- **XGROUP CREATE** 生成一个 `xgroup-create` 事件。
- **XGROUP CREATECONSUMER** 生成一个 `xgroup-createconsumer`事件。
- **XGROUP DELCONSUMER** 生成一个 `xgroup-delconsumer` 事件。
- **XGROUP DESTROY** 生成一个 `xgroup-destory` 事件。
- **XGROUP SETID** 生成一个 `xgroup-setid` 事件。
- **XSETID** 生成一个 `xsetid` 事件。
- [XTRIM](../commands/XTRIM.md) 生成一个 `xtrim` 事件。
- [PERSIST](../commands/PERSIST.md) 当与 key 关联的到期时间已成功删除，生成一个 `persist` 事件。
- 每次一个拥有过期时间的 key 由于过期而从数据集中移除时，将生成一个 `expired` 事件。
- 每次一个 key 由于 maxmemory 策略被从数据集中逐出，以便释放内存时，将生成一个 `evicted` 事件。

**重要** 所有命令仅在正在修改目标 key 时才生成事件。例如，使用 [SREM](../commands/SREM.md) 命令从集合中删除一个不存在的元素将不会改变 key 的值，因此不会生成任何事件。

如果对某个命令如何生成事件有疑问，最简单的方法是自己观察：

```
$ redis-cli config set notify-keyspace-events KEA
$ redis-cli --csv psubscribe '__key*__:*'
Reading messages... (press Ctrl-C to quit)
"psubscribe","__key*__:*",1
```

此时，在另外一个终端使用 redis-cli 发送命令到 Redis 服务器，并观察生成的事件：

```
"pmessage","__key*__:*","__keyspace@0__:foo","set"
"pmessage","__key*__:*","__keyevent@0__:set","foo"
...
```

---

### Timing of expired events

设置了过期时间的键由 Redis 以两种方式过期：
- 当命令访问键时，发现键已过期。
- 通过后台系统在后台逐步查找过期的键，以便能够收集那些从未被访问的键。

当通过以上系统之一访问键且发现键已经过期时，将生成 `expired` 事件。因此无法保证 Redis 服务器在键过期的那一刻同时生成 expired 事件。

如果没有命令不断地访问键，并且有很多键都有关联的 TLL，那么在键的生存时间降低到 0 到生产 `expired` 事件之间，将会有明显的延迟。

基本上，**expired时间是在 Redis 服务器删除键的时候生成的**，而不是在理论上生成事件达到零值时生成的。

---

### Events in a cluster

如上所述，Redis Cluster 的每个节点都会生成有关其自己的键空间子集的事件。但是，与集群中的常规 Pub/Sub 通信不同，事件的通知不会广播到所有节点。换句话说，键空间事件是特定于节点的。这意味着要接受集群的所有键空间事件，客户端需要订阅每个节点。

---

### History

- &gt;= 6.0 : 增加键缺失事件。