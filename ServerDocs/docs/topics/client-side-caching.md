## Redis server-assisted client side caching

客户端缓存是一种用于创建高性能服务的技术。它利用应用程序服务器中的可用内存，与数据库节点相比，这些服务器通常是不同的计算机，以便将数据库信息的某些子集直接存储在应用程序端。

通常当需要一些数据时，应用服务器会向数据库询问这写信息，如下图所示：

```
+-------------+                                +----------+
|             | ------- GET user:1234 -------> |          |
| Application |                                | Database |
|             | <---- username = Alice ------- |          |
+-------------+                                +----------+
```

当使用客户端缓存时，应用程序会将常用查询的结果直接存储在应用程序内存中，以便以后可以重用这些返回值，而无需再次联系数据库。

```
+-------------+                                +----------+
|             |                                |          |
| Application |       ( No chat needed )       | Database |
|             |                                |          |
+-------------+                                +----------+
| Local cache |
|             |
| user:1234 = |
| username    |
| Alice       |
+-------------+
```

虽然用于本地缓存的应用程序内存可能不是很大，但与请求网络服务（如数据库）相比，访问本地计算机内存所需的时间要小几个数量级。

由于经常非常频繁地访问相同的小百分比数据，因此这种模式可以大大减少应用程序获取数据的延迟，同时减少数据库端的负载。

此外，有许多数据集的项目很少更改。例如，社交网络中的大多数用户帖子要么是不可变的，要么很少被用户编辑。加上这一事实，通常一小部分帖子非常受欢迎，要么是因为一小部分用户有很多关注者或因为最近的帖子有更多的可见性，很明显为什么这种模式可以非常有用。

通常客户端缓存的两个主要优点是：
1. 数据以非常小的延迟可用。
2. 数据库系统接收较少的查询，允许使用较少数量的节点提供相同的数据集。

---

### There are only two big problems in computer science...

上述模式的一个问题是如何使用应用程序持有的信息无效，以避免向用户呈现陈旧数据。例如，在上面的应用程序本地缓存 user:1234 信息后，Alice 可能会将他的用户名更新为 Flora。然而，应用程序可能会继续为用户 1234 提供旧用户名。

有时，根据我们正在建模的确切应用程序，这个问题不是什么大问题，因此客户端只会使用固定的最大 "time to live" 来缓存信息。一旦过了给定时间，信息将不再被视为有效。更复杂的模式，在使用 Redis 时，利用 Pub/Sub 系统向监听的客户端发送失效信息。这可以工作，但从使用的带宽的角度来看是棘手的和昂贵的，因为这种模式通常涉及向应用程序中的每个客户端发送失效消息，即使某些客户端可能没有失效数据的任何副本。此外，每个更改数据的应用程序查询都需要使用 [PUBLISH](../commands/publish.md) 命令，这会花费数据库更多的 CPU 时间来处理此命令。

不管使用什么模式，有一个简单的事实：许多非常大的应用程序实现了某种心事的客户端缓存，因为这是拥有快速存储或快速缓存服务器的一个合乎逻辑的步骤。为此，Redis 6 实现了对客户端缓存的直接支持，以使这种模式更易于实现、更易于访问、可靠和高效。

---

### The Redis implementation of client side caching

Redis 客户端缓存支持成为 _Tracking_，有两种模式：
- 在默认模式下，服务器记住给定客户端访问了哪些 key，并在修改相同 key 时发送 key 失效的消息。这会消耗服务器端的内存，但只会为客户端可能在内存中拥有的一组 key 发送失效消息。
- 在 _broadcasting_ 模式中，服务器不会尝试记住给定客户端访问了哪些 key，因此这种模式在服务器端根本不消耗任何内存。相反，客户端订阅 key 前缀，例如 object: 或 user:，并且每次出没与此类前缀匹配的 key 时都会收到通知消息。

回顾一下，现在让我们暂时忘记广播模式，专注于第一种模式。稍后我们将更详细地描述广播。
1. 如果需要，客户端可以启用跟踪。连接开始时未启用跟踪。
2. 启用跟踪后，服务器会记住每个客户端在连接生命周期内请求的 key （通常发送有关此类 key 的读取命令）。
3. 当某个 key 被某个客户端修改，或者因为它有关联的过期时间而被逐出时，或者因为 _maxmemory_ 策略而被逐出时，所有可能缓存了 key 的启用跟踪的客户端都会收到一条 *失效消息* 通知。
4. 当客户端收到失效消息时，它们需要删除相应的 key，以避免提供过时的数据。

这是协议的一个例子：
- Client 1 -> Server: CLIENT TRACKING ON
- Client 1 -> Server: GET foo
- （服务器记住客户端 1 可能缓存了 key "foo"）
- （客户端 1 可能会记住其本地内存中 "foo" 的值）
- Client 2 -> Server: SET foo SomeOtherValue
- Server -> Client 1: INVALIDATE "foo"

从表面上看，这看起来很棒，但是如果您认为有 1 万个连接的客户端在每个长期连接的故事中都要求数百万个 key，那么服务器最终会存储太多信息。出于这个原因，Redis 使用两个关键思想来限制服务器端使用的内存量，以及处理实现该功能的数据结构的 CPU 成本：
- 服务器记住可能在单个全局表中缓存给定 key 的客户端列表。该表成为 **Invalidation Table**。这样的失效表尅包含最大数量的条目，如果插入了新的 key，服务器可以通过假装这样的 key 被修改（即使没有）来驱逐旧的条目，并向客户端发送失效消息。这样做，它可以回收用于该 key 的内存，即使这样强制具有该 key 的本地副本的客户端驱逐他。
- 在失效表中，我们实际上并不需要存储指向客户端结构的指针，这会在客户端断开连接时强制执行垃圾收集过程：相反，我们所做的知识存储客户端 ID（每个 Redis 客户端有一个唯一的数字 ID）。如果客户端断开连接，则随着缓存槽失效，信息将被逐步垃圾收集。
- 有一个单独的 key 命名空间，不按数据库编号划分。因此，如果客户端正在缓存数据库 2 中的 key foo，而其他一些客户端更改了数据库 3 中 key foo 的值，则仍将发送失效消息。通过这种方式，我们可以忽略数据库编号，从而减少内存使用和实现复杂性。

---

### Two connections mode

使用 Redis 6 支持的新版本 Redis 协议 RESP3，可以在同一连接中运行数据查询和接收失效消息。然而，许多客户端实现可能更喜欢使用两个分离的连接来实现客户端缓存：一个用于数据，另一个用于失效消息。为此，文档客户端启用 tracking 时，它可以通过指定不同连接的 "client ID" 来指定将失效消息重定向到另一个连接。许多数据连接可以将失效消息重定向到同一个连接，这对于实现连接池的客户端很有用。两种连接模型是唯一一种也支持 RESP2 （缺乏在同一连接中重复不同类型信息的能力）的模型。

我们将展示一个例子，这次通过在旧的 RESP2 模式下使用实际的 Redis 协议，如何完整的会话，包括以下步骤：启用跟踪重定向到另一个连接，请求一个 key，并在该 key 被修改后获得一个失效消息。

首先，客户端打开将用于失效的第一个连接，请求连接 ID，并通过 Pub/Sub 订阅用于在 RESP2 模式下获取失效消息的特殊通道（请记住，RESP2 是通常的 Redis 协议，而不是您可以使用的更高级的协议，您可以选择使用 [HELLO](../commands/HELLO.md) 命令与 Redis 6 一起使用）：

```
(Connection 1 -- used for invalidations)
CLIENT ID
:4
SUBSCRIBE __redis__:invalidate
*3
$9
subscribe
$20
__redis__:invalidate
:1
```

现在我们可以从数据连接启用跟踪：

```
(Connection 2 -- data connection)
CLIENT TRACKING on REDIRECT 4
+OK

GET foo
$3
bar
```

客户端可以决定在本地内存中缓存 "foo" => "bar"。

另一个客户端现在将修改 key ("foo") 的值。

```
(Some other unrelated connection)
SET foo bar
+OK
```

因此，失效连接将受到一条使指定 key 失效的消息。

```
(Connection 1 -- used for invalidations)
*3
$7
message
$20
__redis__:invalidate
*1
$3
foo
```

客户端将检查改缓存槽中是否有缓存的 key，并将不再有效的信息逐出。

请注意，Pub/Sub 消息的第三个元素不是单个 key，而是一个只有单个元素的 Redis 数组。由于我们发送一个数组，如果有一组 key 要失效，我们可以在单个消息中完成。

了解与 RESP2 一起使用的客户端缓存以及 Pub/Sub 连接以读取失效消息的一个非常重要的事情是，使用 Pub/Sub 完全是为了重用就客户端实现的技巧，但实际上并不是真正的消息发送到一个通道和接收所有客户端订阅。只有我们在 CLIENT 命令的 REDIRECT 参数中指定的连接才会实际接收 Pub/Sub 消息，从而使该功能更具可扩展性。

当使用 RESP3 时，失效消息将作为推送消息发送（在同一连接中或在使用重定向时在辅助连接中）（阅读 RESP3 规范以获取更多信息）。

---

### What tracking tracks

如您所见，默认情况下，客户端不需要告诉服务器它们正在缓存哪些 key。服务器会跟踪只读命令上下文中提到的每个 key，因为它*可以被缓存*。

这有一个明显的优点，即不需要客户端告诉服务器它正在缓存什么。此外，在许多客户端实现中，这正是您想要的，因为一个好的解决方案可能是使用先进的方法缓存尚未缓存的所有内容：我们可能希望缓存固定数量的对象，每个我们检索到的新数据，我们可以缓存它，丢失最旧的缓存对象。更高级的实现可能会删除最少使用的对象。

请注意，无论如何，如果服务器上存在写入流量，缓存槽将再次期间失效。一般来说，当服务器假设我们得到的东西也缓存时，我们正在做一个权衡：

1. 当客户端倾向于使用欢迎新对象的策略缓存许多东西时，效率会更高。
2. 服务器将被迫保留有关客户端 key 的更多数据。
3. 客户端将受到关于它没有缓存的对象的无用的失效消息。

因此，下一节将介绍一种替代方法。

---

### Opt-in caching

客户端实现可能只想缓存指定的 key，并明确地与服务器通信它们将缓存什么和不缓存什么：要记住，这将在缓存新对象时需要更多的带宽，但同时会减少服务器拥有的数据量，以及客户端收到的失效消息的数量。

为此，必须使用 `OPTIN` 选项启用 tracking：

```
CLIENT TRACKING on REDIRECT 1234 OPTIN
```

在这种模式下，读取查询中提到的默认 key 不应该被缓存，相反，当客户端想要缓存某些东西时，他必须在实际命令之前逻辑发送一个特殊命令来检索数据：

```
CLIENT CACHING YES
+OK
GET foo
"bar"
```

`CACHING` 命令会影响在它之后执行的命令，但是如果下一个命令是 [MULTI](../commands/MULTI.md)，则将跟踪事务中的所有命令。同样的，在 Lua 脚本的情况下，脚本执行的所有命令都将被跟踪。

---

### Broadcasting mode

到目前为止，我们描述了 Redis 实现的第一个客户端缓存模型。还有一种叫做 广播(broadcasting)，他从不同的权衡的角度看待问题，它不消耗服务器端的任何内存，而是想客户端发送更多的失效消息。在这种模式下，我们有以下主要行为：

- 客户端使用 `BCAST` 选项启用客户端缓存，使用 `PREFIX` 选项指定一个或多个前缀。 例如：在 `REDIRECT 10 BCAST PREFIX` 对象上的 `CLIENT TRACKING` ：`PREFIX user:`。如果根本没有指定前缀，则假定前缀为空字符串，因此客户端将受到每个被修改的 key 的失效消息。相反，如果使用一个或多个前缀，则只有与指定前缀之一匹配的 key 才会在失效消息中发送。
- 服务器不会在失效表中存储任何内容。相反，它仅使用不同的**前缀表(Prefixes Table)**，其中每个前缀都与客户端列表相关联。
- 没有两个前缀客户跟踪键空间的重叠部分。例如，不允许使用前缀 `foo` 和 `fob`，因为它们都会触发 key `foobar` 的失效。但是，仅使用前缀 `foo` 就足够了。
- 每次修改与任何前缀匹配的 key 时，所有订阅该前缀的客户端都会收到失效消息。
- 服务器消耗与注册前缀数量成正比的 CPU。如果您只有几个，则很难看出任何区别。使用大量前缀时，CPU 成本会变得非常大。
- 在这种模式下，服务器可以执行优化，为订阅给定前缀的所有客户端创建单个回复，并向所有客户端发送相同的回复。这有助于降低 CPU 使用率。

---

### The NOLOOP option

默认情况下，客户端跟踪甚至会向修改 key 的客户端发送失效消息。有时客户端想要这个，因为它们实现了一个非常基本的逻辑，不涉及在本地自动缓存写入。然而，更高级的客户端可能甚至希望缓存它们在本地内存表中所做的写入。在这种情况下，在写入后立即收到无效消息是一个问题，因为它会强制客户端逐出它刚刚缓存的 key。

在这种情况下，可以使用 `NOLOOP` 选项：它可以在正常和广播模式下工作。使用这样的选项，客户端可以告诉服务器它们不想收到自己修改的 key 的失效消息。

---

### Avoiding race conditions

当实现客户端缓存将失效消息重定向到不同的连接时，您应该意识到可能存在竞争条件。请参阅一下示例交互，我们将在其中调用数据连接 "D" 和无效连接 "I"：

```
[D] client -> server: GET foo
[I] server -> client: Invalidate foo (somebody else touched it)
[D] server -> client: "bar" (the reply of "GET foo")
```

如您所见，由于对 GET 的回复到达客户端的速度比较慢，因此我们在已经不再有效的实际数据之前收到了失效消息。因此，我们将继续提供 key foo 的旧版本。为了避免这个问题，当我们发送带有占位符的命令时，最好填充缓存：

```
Client cache: set the local copy of "foo" to "caching-in-progress"
[D] client-> server: GET foo.
[I] server -> client: Invalidate foo (somebody else touched it)
Client cache: delete "foo" from the local cache.
[D] server -> client: "bar" (the reply of "GET foo")
Client cache: don't set "bar" since the entry for "foo" is missing.
```

当对数据和失效消息使用单个连接时，这种竞争条件是不可能的，因为在这种情况下，消息的顺序总是已知的。

---

### What to do when losing connection with the server

类似的，如果我们失去了鱼我们用来获取失效消息的套接字的连接，我们可能会以旧数据结束。为了避免这个问题，我们需要做以下几件事：

1. 确保如果连接丢失，则刷新本地缓存。
2. 无论是在 Pub/Sub 还是 RESP3 中使用 RESP2 时，都要定期 ping 失效通道（即使连接处于 Pub/Sub 模式，您也可以发送 PING 命令！）。如果连接懒起来已断开并且我们无法接收到 ping 返回，请在最长时间后关闭连接并刷新缓存。

---

### What to cache

客户端可能希望运行关于给定缓存 key 在请求中实际提供的次数的内部统计信息，以便将来了解缓存的好处。一般来说：

- 我们不想缓存许多不断变化的 key。
- 我们不想缓存很多很少请求的 key。
- 我们希望缓存经常请求并以合理速率更改 key。对于 key 未以合理速率更改的示例，请考虑持续递增的全局计数器。

然而，更简单的客户端可能只是使用一些随机抽样来逐出数据，只是记住上次提供给缓存值的时间，视图逐出最近未提供服务的 key。

---

### Other hints about client libraries implementation

- 处理 TTL：如果您想支持使用 TTL 缓存 key，请确保您还请求 key  TTL 并在本地缓存中设置 TTL。
- 在每个 key 中防止一个最大 TTL 是一个好主意，即使他没有 TTL。这是防止错误或连接问题的良好保护，这些错误或连接问题会使客户端在本地副本中拥有旧数据。
- 绝对需要限制客户端使用的内存量。添加新 key 时，必须有一种方法客户端逐出旧 key。

---

### Limiting the amount of memory used by Redis

只需确保为 Redis 记住的最大 key 数量配置一个合适的值，或者在 Redis 端使用我取暖器不消耗内存的 BCAST 模式。请注意，当不使用 BCAST 时，Redis 消耗内存与跟踪的 key 数量和请求此类 key 的客户端数量成正比。
